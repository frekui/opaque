// Copyright (c) 2018 Fredrik Kuivinen, frekui@gmail.com
//
// Use of this source code is governed by the BSD-style license that can be
// found in the LICENSE file.
//

// Package dh contains functions to perform a Diffie-Hellman key exchange over
// the group Z^*_p for a prime p.
package dh

import (
	"crypto/rand"
	"crypto/sha256"
	"math"
	"math/big"
)

// Group represents the group Z^*_p.
type Group struct {
	// Group generator.
	G *big.Int

	// Group order.
	P *big.Int
}

// Rfc3526_2048 is the 2048-bit MODP Group from RFC 3526.
var Rfc3526_2048 Group

func init() {
	p, ok := new(big.Int).SetString("FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF", 16)
	if !ok {
		panic("big.Int SetString failed")
	}
	g := new(big.Int).SetInt64(2)
	Rfc3526_2048 = Group{G: g, P: p}
}

// Bytes returns the absolute value of x as a big-endian byte slice. The length
// of the slice is padded with zeros so that the length of the returned slice is
// always the same for a given group.
func (g Group) Bytes(x *big.Int) []byte {
	z := new(big.Int)
	z.Mod(x, g.P)
	b := z.Bytes()
	bytelen := int(math.Ceil(float64(g.P.BitLen()) / 8))
	padLen := bytelen - len(b)
	res := make([]byte, bytelen)
	copy(res[padLen:], b)
	return res
}

// IsInSmallSubgroup returns true if x belongs to a small subgroup of Z^*_p.
//
// Precondition: p is a safe prime (i.e., p is prime and (p-1)/2 is prime.).
//
// As p is a safe prime there are only three sizes of subgroups: one, two, and,
// (p-1)/2 elements. The subgroups containing one and two elements are
// considered to be small.
func (g Group) IsInSmallSubgroup(x *big.Int) bool {
	if x.Cmp(big.NewInt(1)) == 0 {
		return true
	}
	pm1 := new(big.Int)
	pm1.Sub(g.P, big.NewInt(1))
	if x.Cmp(pm1) == 0 {
		return true
	}
	return false
}

// IsInGroup returns true if x is in the group Z^*_p and false otherwise.
func (g Group) IsInGroup(x *big.Int) bool {
	if big.NewInt(0).Cmp(x) != -1 || x.Cmp(g.P) != -1 {
		return false
	}
	return true
}

// GeneratePrivateKey generates a private key to be used in a Diffie-Hellman key
// exchange in the group g.
func (g Group) GeneratePrivateKey() (*big.Int, error) {
	for {
		key, err := rand.Int(rand.Reader, g.P)
		if err != nil {
			return nil, err
		}
		if key.Sign() != 0 {
			return key, nil
		}
	}
}

// GeneratePublicKey creates a public key which corresponds to the private key
// privKey.
func (g Group) GeneratePublicKey(privKey *big.Int) *big.Int {
	ret := new(big.Int)
	return ret.Exp(g.G, privKey, g.P)
}

// SharedSecret returns a byte slice which is the secret shared between two
// peers who have performed a Diffie-Hellman key exchange.
//
// If priv1 and priv2 are two private keys generated by GeneratePrivateKey and
// pub1 and pub2 are public keys created using GeneratePublicKey from priv1 and
// priv2, respectively, then the byte slices returned by SharedSecret(priv1,
// pub2) and SharedSecret(priv2, pub1) are identical.
func (g Group) SharedSecret(privKey *big.Int, otherPubKey *big.Int) []byte {
	s := new(big.Int)
	s.Exp(otherPubKey, privKey, g.P)
	h := sha256.New()
	h.Write(s.Bytes())
	return h.Sum(nil)
}
